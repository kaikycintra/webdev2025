<!DOCTYPE html>
<html lang="pt-br">

    <head>

        <title>Aula 3</title>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" href="aulas.css">

    </head>

    <body>

        <main class="col-lg">

            <!-- Sumário -->
            <div id="lecture-3">

            <h1 class="no_toc">Aula 3: Django</h1>

            <ul id="markdown-toc">

                <li><a href="#introduction" id="markdown-toc-introduction">Introdução</a></li>
                <li><a href="#web-applications" id="markdown-toc-web-applications">Aplicações Web</a></li>
                <li><a href="#http" id="markdown-toc-http">HTTP</a></li>
                <li><a href="#django" id="markdown-toc-django">Django</a></li>
                <li><a href="#routes" id="markdown-toc-routes">Rotas</a></li>
                <li><a href="#templates" id="markdown-toc-templates">Templates</a>    
                    <ul>
                        <li><a href="#conditionals" id="markdown-toc-conditionals">Condicionais</a></li>
                        <li><a href="#styling" id="markdown-toc-styling">Estilização</a></li>
                    </ul>
                </li>
                <li><a href="#tasks" id="markdown-toc-tasks">Tarefas</a></li>
                <li><a href="#forms" id="markdown-toc-forms">Formulários</a>    
                    <ul>
                        <li><a href="#django-forms" id="markdown-toc-django-forms">Formulários do Django</a></li>
                    </ul>
                </li>
                <li><a href="#sessions" id="markdown-toc-sessions">Sessões</a></li>

            </ul>

            </div>

            <!-- Introdução -->
            <div id="introduction">

            <h2>Introdução</h2>

            <ul>

                <li data-marker="*">
                    Até agora, discutimos como construir páginas web simples usando HTML e CSS.
                </li>
                <li data-marker="*">
                    Hoje, vamos trabalhar com o framework do Python chamado <code class="plaintext">Django</code> para criar aplicações dinâmicas.
                </li>

            </ul>

            </div>

            <!-- Aplicações Web -->
            <div id="web-applications">

            <h2>Aplicações Web</h2>

            <p>
                Até agora, todas as aplicações web que escrevemos foram <strong>estáticas</strong>. Isso significa que, sempre que abrimos aquela página, ela aparece exatamente da mesma forma. 
                No entanto, muitos sites que visitamos diariamente mudam toda vez que os acessamos. Se você visitar os sites do <a href="https://www.youtube.com/" target="_blank">Youtube</a> ou do <a href="https://g1.globo.com/" target="_blank">G1</a>, 
                por exemplo, o conteúdo da página hoje é diferente do conteúdo que terá amanhã e já é diferente do conteúdo de ontem. 
            </p>

            <p>
                Para sites grandes como esses, é inviável que os funcionários tenham que editar manualmente grandes arquivos HTML a cada alteração. É aí que os sites <strong>dinâmicos</strong> são extremamente úteis. 
                Um site dinâmico utiliza uma linguagem de programação (como Python) para gerar HTML e CSS dinamicamente. Nesta aula, aprenderemos a criar nossas primeiras aplicações dinâmicas.
        
            </p>

            </div>
            
            <!-- HTTP -->
            <div id="http">

            <h2>HTTP</h2>

            <p>
                Protocolo de Transferência de Hipertexto (HyperText Transfer Protocol ou HTTP), é um protocolo amplamente aceito para a troca de mensagens na internet. Normalmente, as informações são trocadas entre um usuário (cliente) e um servidor.
            </p>

            <p>
                Nesse protocolo, o cliente envia uma <strong>requisição</strong> para o servidor (falaremos sobre três tipos de requisição neste curso). Depois, o servidor envia uma resposta HTTP para o usuário que inclui um código de status, uma descrição do conteúdo 
                e outras informações como a versão do HTTP.
            </p>

            <p>
                Os códigos de status são importantes pois indicam se a requisição foi concluída corretamente ou não. Observe abaixo alguns dos códigos de status e seus significados:

                <table>

                    <thead>
                        <tr>
                            <th scope="col">Código de Status</th>
                            <th scope="col">Significado</th>
                        </tr>
                    </thead>

                    <tbody>

                        <tr>
                            <td scope="row">200</td>
                            <td>OK</td>
                        </tr>

                        <tr>
                            <td scope="row">404</td>
                            <td>Not Found</td>
                        </tr>

                        <tr>
                            <td scope="row">500</td>
                            <td>Internal Server Error</td>
                        </tr>

                        <tr>
                            <td scope="row">403</td>
                            <td>Forbidden</td>
                        </tr>

                        <tr>
                            <td scope="row">301</td>
                            <td>Moved Permanently</td>
                        </tr>

                    </tbody>

                </table>
            </p>

            </div>

            <!-- Django -->
            <div id="django">

            <h2>Django</h2>

            <p>
                <a href="https://www.djangoproject.com/" target="_blank">Django</a> é um framework web baseado em Python que nos permite escrever código Python para gerar HTML e CSS de forma dinâmica. 
                A vantagem de usar um framework como o Django é que muito do código já está pronto para usarmos.
            </p>

            <ul>
                <li data-marker="*">Para começar, precisamos instalar o Django, o que também exige <a href="https://pip.pypa.io/en/stable/installation/" target="_blank"> instalar o pip</a> caso ainda não o tenha instalado.</li>
                <li data-marker="*">Uma vez que o pip estiver instalado, você pode executar <code class="plaintext">pip3 install Django</code> no terminal para instalar o Django.</li>
            </ul>

            <p>
                Depois de instalar o Django, podemos seguir os passos para criar um novo projeto:
            </p>

            <ol>

                <li>Execute <code class="plaintext">django-admin startproject NOME_PROJETO</code> para criar os arquivos iniciais do projeto.</li>
                <li>Navegue até o diretório do projeto com <code class="plaintext">cd NOME_PROJETO</code></li>

                <li>Você verá que alguns arquivos foram criados automaticamente. Por enquanto, três deles são mais importantes:
                    <ul>
                        <li data-marker="*"><code class="plaintext">manage.py</code>: usado para executar comandos no terminal. Não precisamos editá-lo, mas vamos usá-lo com frequência.</li>
                        <li data-marker="*"><code class="plaintext">settings.py</code>: contém configurações importantes do projeto. Podemos alterar algumas delas eventualmente.</li>
                        <li data-marker="*"><code class="plaintext">urls.py</code>: define para onde o usuário será direcionado ao acessar certas URLs.</li>
                    </ul>
                </li>

                <li>
                    Inicie o projeto executando <code class="plaintext">python manage.py runserver</code>. Isso abrirá um servidor de desenvolvimento, que você pode acessar visitando a URL fornecida. 
                    Este servidor de desenvolvimento está sendo executado localmente na sua máquina, o que significa que outras pessoas não podem acessar seu site. Isso deve levá-lo a uma página de destino padrão:
                    <br>
                    <img src="static3/django.png" alt="Página inicial do Django">
                    <br>
                </li>

                <li>
                    Agora, precisamos criar uma aplicação. Projetos Django são divididos em uma ou mais <strong>aplicações</strong>. A maioria dos nossos projetos de exemplo terão apenas uma aplicação, mas sites maiores podem usar várias. Para criar uma, execute: 
                    <code class="plaintext">python manage.py startapp NOME_APP</code>. Isso criará novos diretórios e arquivos que necessitamos, como o <code class="plaintext">views.py</code>.
                </li>

                <li>
                    Precisamos instalar a nova aplicação. Para isso, edite <code class="plaintext">settings.py</code>, role até a lista <code class="plaintext">INSTALLED_APPS</code>, 
                    e adicione o nome da aplicação na lista.
                    <br>
                    <img src="static3/novo_app.png" alt="Lista INSTALLED_APPS">
                    <br>
                    No nosso exemplo, criamos o app Users, que será nossa página do usuário.
                </li>

            </ol>

            </div>

            <!-- Rotas -->
            <div id="routes">

            <h2>Rotas</h2>

            <p>Para iniciar nossa aplicação:</p>

            <ol>

                <li>

                    <p>
                        No diretório criado para o app, abra o arquivo <code class="plaintext">views.py</code>. Esse arquivo conterá diferentes views, que podem ser entendidas como páginas que o usuário pode visitar. 
                        Para criar nossa primeira view, escreveremos uma função que recebe um <code class="plaintext">request</code>. 
                        Por enquanto, vamos retornar simplesmente um <code class="plaintext">HttpResponse</code> 
                        (uma forma de resposta muito simples que inclui um código de resposta 200 e uma string de texto que pode ser visualizada em um navegador) 
                        com “ Oi Usuário!”. Para fazer isso, temos que adicionar ao código <code class="plaintext">from django.http import HttpResponse</code>. Nosso arquivo está como abaixo:
                    </p>

<pre><code>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">shortcuts</span> <span class="func">import</span> <span class="nome-func">render</span>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">http</span> <span class="func">import</span> <span class="lib">HttpResponse</span>

<span class="pComment"># Crie suas views aqui.</span>

<span class="func">def</span> <span class="nome-func">index</span><span class="p">(</span><span class="python">request</span><span class="p">)</span><span>:</span>
    <span class="func">return</span> <span class="lib">HttpResponse</span><span class="p">(</span><span class="string">"Oi Usuário!"</span><span class="p">)</span>

</code></pre>

                </li>

                <li>
                    Agora, precisamos associar essa view a uma URL. Para isso, criaremos um novo arquivo chamado <code class="plaintext">urls.py</code> 
                    no mesmo diretório de <code class="plaintext">views.py</code>. Note que já existe um <code class="plaintext">urls.py</code> 
                    do projeto, mas é melhor ter um para cada app separadamente.
                </li>

                <li>No novo <code class="plaintext">urls.py</code>, criamos uma lista de padrões de URL que o usuário pode acessar enquanto no nosso site:

                    <ol>

                        <li>
                            Temos que fazer mais alguns imports: <code class="plaintext">from django.urls import path</code> nos dá a habilidade de redirecionar URLs, 
                            e <code class="plaintext">from . import views</code> importará quaisquer funções que implementamos em <code class="plaintext">views.py</code>.
                        </li>

                        <li>Crie uma lista chamada <code class="plaintext">urlpatterns</code></li>

                        <li>
                            Para cada URL desejada, adicione um item na lista <code class="plaintext">urlpatterns</code> 
                            que tenha uma chamada da função <code class="plaintext">path</code> com dois ou três argumentos: 
                            Uma string representando o caminho da URL, uma função de <code class="plaintext">views.py</code> 
                            que desejamos executar quando aquela URL é visitada, e (opcional) um nome para o caminho, no formato <code class="plaintext">name="meu_caminho"</code>. Por exemplo, veja como está nosso código agora:
                        </li>

                    </ol>

<pre><code>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">urls</span> <span class="func">import</span> <span class="nome-func">path</span>
<span class="func">from</span> <span>.</span> <span class="func">import</span> <span class="lib">views</span>

<span class="python">urlpatterns</span> <span class="pComment">=</span> <span class="p">[</span>
    <span class="nome-func">path</span><span class="p2">(</span><span class="string">""</span><span>,</span> <span class="lib">views</span><span>.</span><span class="nome-func">index</span><span>,</span> <span class="python">name</span><span class="pComment">=</span><span class="string">"index"</span><span class="p2">)</span>
<span class="p">]</span>

</code></pre>

                </li>

                <li>

                    <p>

                        Assim, criamos um <code class="plaintext">urls.py</code> para essa aplicação. Agora devemos editar o <code class="plaintext">urls.py</code> do projeto. 
                        Quando você abrir esse arquivo, perceberá que já existe um caminho chamado <code class="plaintext">admin</code>, que será explicado na aula seguinte. 
                        No momento, desejamos adicionar um caminho para nosso novo app, então adicionamos um item na lista <code class="plaintext">urlpatterns</code>. 
                        Isso segue o mesmo padrão dos nossos caminhos anteriores, exceto que, em vez de adicionar uma função de <code class="plaintext">views.py</code> 
                        como segundo argumento, queremos incluir <em>todos</em> os caminhos do arquivo <code class="plaintext">urls.py</code> em nossa aplicação. 
                        Para fazer isso, escrevemos: <code class="plaintext">include("NOME_APP.urls")</code>, onde <code class="plaintext">include</code> 
                        é uma função à qual obtemos acesso importando <code class="plaintext">include</code> de <code class="plaintext">django.urls</code> 
                        conforme mostrado abaixo:
                    
                    </p>

<pre><code>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">contrib</span> <span class="func">import</span> <span class="lib">admin</span>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">urls</span> <span class="func">import</span> <span class="nome-func">path</span><span>,</span> <span class="nome-func">include</span>

<span class="python">urlpatterns</span> <span class="pComment">=</span> <span class="p">[</span>
    <span class="nome-func">path</span><span class="p2">(</span><span class="string">'admin/'</span><span>,</span> <span class="lib">admin</span><span>.</span><span class="func">site</span><span>.</span><span class="func">urls</span><span class="p2">)</span><span>,</span>
    <span class="nome-func">path</span><span class="p2">(</span><span class="string">'user/'</span><span>,</span> <span class="nome-func">include</span><span class="p3">(</span><span class="string">"Users.urls"</span><span class="p3">)</span><span class="p2">)</span>
<span class="p">]</span>

</code></pre>

                </li>
                
                <li>
                    Ao fazer isso, especificamos que, quando um usuário visitar nosso site e adicionar  <code class="plaintext">/user</code> 
                    à URL na barra de endereços, ele será redirecionado para os caminhos definidos dentro da nossa nova aplicação.
                </li>

            </ol>

            <p>

                Agora, quando se iniciar a aplicação usando <code class="plaintext">python manage.py runserver</code> e visitar a URL fornecida, temos seguinte tela:
                <br>
                <img src="static3/not_found.png" alt="erro 404">
                <br>
                Isso ocorre porque definimos apenas a URL <code class="plaintext">localhost:8000/user</code>, mas não definimos a URL 
                <code class="plaintext">localhost:8000</code> sem nada no final. Então, ao adicionar <code class="plaintext">/user</code> na barra de endereços:
                <br>
                <img src="static3/oi_usuario.png" alt="Oi Usuário!">
                <br>
                Agora que tivemos sucesso, vamos revisar o que acabou de acontecer para chegarmos a esse ponto:
                
            </p>

            <ol>
                <li>
                    Quando acessamos a URL <code class="plaintext">localhost:8000/users/</code>, o Django analisou o que veio após a URL base 
                    (<code class="plaintext">localhost:8000/</code>) e procurou no arquivo <code class="plaintext">urls.py</code> 
                    do projeto por um padrão que correspondesse a <code class="plaintext">Users</code>.
                </li>

                <li>Ele encontrou a extensão que definimos e verificou que, ao encontrá-la, deveria incluir o arquivo <code class="plaintext">urls.py</code> da nossa aplicação.</li>

                <li>
                    Em seguida, o Django ignorou as partes da URL já utilizadas no redirecionamento (<code class="plaintext">localhost:8000/users/</code>, 
                    ou tudo isso) e procurou no <code class="plaintext">urls.py</code> da aplicação um padrão que correspondesse ao restante da URL.
                </li>

                <li>
                    Ele encontrou que o único caminho definido até agora (<code class="plaintext">""</code>) correspondia ao que restava da URL, e então nos direcionou à função index de 
                    <code class="plaintext">views.py</code> associada a esse caminho.
                </li>

                <li>Por fim, o Django executou essa função dentro de <code class="plaintext">views.py</code>, e retornou o resultado (<code class="plaintext">HttpResponse("Hello, world!")</code>) para o navegador.</li>

            </ol>

            <p>
                Agora, se quisermos, podemos alterar a função <code class="plaintext">index</code> dentro de <code class="plaintext">views.py</code> 
                para retornar o que quisermos! Podemos até mesmo manter variáveis e fazer cálculos dentro da função antes de retornar algo.
            </p>

            <p>Agora, vamos ver como podemos adicionar mais de uma view à nossa aplicação. Podemos seguir muitos dos mesmos passos para criar páginas que cumprimentam alguns usuários específicos.</p>

            <p>Dentro de <code class="plaintext">views.py</code>:</p>

<pre><code>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">shortcuts</span> <span class="func">import</span> <span class="nome-func">render</span>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">http</span> <span class="func">import</span> <span class="lib">HttpResponse</span>

<span class="pComment"># Crie suas views aqui.</span>

<span class="func">def</span> <span class="nome-func">index</span><span class="p">(</span><span class="python">request</span><span class="p">)</span><span>:</span>
    <span class="func">return</span> <span class="lib">HttpResponse</span><span class="p">(</span><span class="string">"Oi Usuário!"</span><span class="p">)</span>

<span class="func">def</span> <span class="nome-func">kaiky</span><span class="p">(</span><span class="python">request</span><span class="p">)</span><span>:</span>
    <span class="func">return</span> <span class="lib">HttpResponse</span><span class="p">(</span><span class="string">"Oi Kaiky!"</span><span class="p">)</span>

<span class="func">def</span> <span class="nome-func">rafael</span><span class="p">(</span><span class="python">request</span><span class="p">)</span><span>:</span>
    <span class="func">return</span> <span class="lib">HttpResponse</span><span class="p">(</span><span class="string">"Oi Rafael!"</span><span class="p">)</span>

</code></pre>

            <p>Dentro de <code class="plaintext">urls.py</code> (na aplicação, não no projeto)</p>

<pre><code>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">urls</span> <span class="func">import</span> <span class="nome-func">path</span>
<span class="func">from</span> <span>.</span> <span class="func">import</span> <span class="lib">views</span>

<span class="python">urlpatterns</span> <span class="pComment">=</span> <span class="p">[</span>
    <span class="nome-func">path</span><span class="p2">(</span><span class="string">""</span><span>,</span> <span class="lib">views</span><span>.</span><span class="nome-func">index</span><span>,</span> <span class="python">name</span><span class="pComment">=</span><span class="string">"index"</span><span class="p2">)</span><span>,</span>
    <span class="nome-func">path</span><span class="p2">(</span><span class="string">"kaiky"</span><span>,</span> <span class="lib">views</span><span>.</span><span class="nome-func">kaiky</span><span>,</span> <span class="python">name</span><span class="pComment">=</span><span class="string">"kaiky"</span><span class="p2">)</span><span>,</span>
    <span class="nome-func">path</span><span class="p2">(</span><span class="string">"rafael"</span><span>,</span> <span class="lib">views</span><span>.</span><span class="nome-func">rafael</span><span>,</span> <span class="python">name</span><span class="pComment">=</span><span class="string">"rafael"</span><span class="p2">)</span>
<span class="p">]</span>

</code></pre>

            <p>
                Agora, o site permanece igual quando visitamos <code class="plaintext">localhost:8000/user</code>, 
                mas temos páginas diferentes quando adicionamos <code class="plaintext">kaiky</code> ou <code class="plaintext">rafael</code> no final da URL:
                <br>
                <img src="static3/oi_kaiky.png" alt="Kaiky">
                <br>
                <img src="static3/oi_rafael.png" alt="Rafael">
                <br>
            </p>

            <p>
                Muitos sites são parametrizados por itens incluídos na URL. Por exemplo, acessar <a href="https://www.youtube.com/CodeLabBR" target="_blank">www.youtube.com/CodeLabBR</a> 
                mostrará todos os vídeos publicados pelo CodeLab, e acessar <a href="https://www.instagram.com/uspcodelab/" target="_blank">www.instagram.com/uspcodelab/</a> levará você à página do CodeLab no Instagram. 
                Você pode até encontrar seu próprio perfil do Instagram navegando até <code class="plaintext">www.instagram.com/SEU_@/</code>!
            </p>

            <p>
                Ao pensar em como isso é implementado, parece impossível que sites como o Youtube e o Instagram tenham um caminho de URL individual para cada usuário. 
                Então, vamos ver como podemos criar um caminho mais flexível. Vamos começar adicionando uma função mais geral, chamada <code class="plaintext">usuario</code>, 
                ao <code class="plaintext">views.py</code>:
            </p>

<pre><code>
<span class="func">def</span> <span class="nome-func">usuario</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="python">nome</span><span class="p">)</span><span>:</span>
    <span class="func">return</span> <span class="lib">HttpResponse</span><span class="p">(</span><span class="func">f</span><span class="string">"Oi </span><span class="p2">{</span><span class="python">nome</span><span class="p2">}</span><span class="string">!"</span><span class="p">)</span>

</code></pre>

            <p>
                Essa função recebe não apenas a requisição, mas também um argumento adicional com o nome do usuário, e retorna uma resposta HTTP personalizada baseada nesse nome. 
                Em seguida, precisamos criar um caminho mais flexível em <code class="plaintext">urls.py</code>:
            </p>

<pre><code>
<span class="nome-func">path</span><span class="p">(</span><span class="string">"&lt;str:nome&gt;"</span><span>,</span> <span class="lib">views</span><span>.</span><span class="nome-func">usuario</span><span>,</span> <span class="python">name</span><span class="pComment">=</span><span class="string">"usuario"</span><span class="p2">)</span>

</code></pre>

            <p>
                Essa é uma nova sintaxe, mas, essencialmente, estamos dizendo que não estamos mais procurando uma palavra ou nome específico na URL, mas qualquer string que o usuário possa digitar. Agora, podemos testar o site com algumas URLs diferentes:
                <br>
                <img src="static3/oi_ryan.png" alt="ryan">
                <br>
                <img src="static3/oi_vitor.png" alt="vitor">
                <br>
            </p>

            <p>
                Podemos até deixar isso um pouco mais bonito, melhorando a função <code class="plaintext">usuario</code> 
                com a função <code class="plaintext">capitalize</code> do Python, que coloca a primeira letra em maiúsculo:
            </p>

<pre><code>
<span class="func">def</span> <span class="nome-func">usuario</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="python">nome</span><span class="p">):</span>
    <span class="func">return</span> <span class="lib">HttpResponse</span><span class="p">(</span><span class="func">f</span><span class="string">"Oi </span><span class="p2">{</span><span class="python">nome</span><span>.</span><span class="nome-func">capitalize</span><span class="p3">()</span><span class="p2">}</span><span class="string">!"</span><span class="p">)</span>

</code></pre>

            <p>
                <br>
                <img src="static3/oi_ryan2.png" alt="Ryan">
                <br>
                <img src="static3/oi_vitor2.png" alt="Vitor">
                <br>
            </p>

            <p>Essa é uma ótima ilustração de como qualquer funcionalidade do Python pode ser usada no Django antes de ser retornada.</p>
        
            </div>

            <!-- Templates -->
            <div id="templates">

            <h2>Templates</h2>

            <p>
                Até agora, nossas respostas HTTP foram apenas texto, mas podemos incluir qualquer elemento HTML que quisermos! 
                Por exemplo, eu poderia decidir retornar um cabeçalho azul em vez de apenas texto na nossa função 
                <code class="plaintext">index</code>:
            </p>

<pre><code>
<span class="func">def</span> <span class="nome-func">index</span><span class="p">(</span><span class="python">request</span><span class="p">)</span><span>:</span>
    <span class="func">return</span> <span class="lib">HttpResponse</span><span class="p">(</span><span class="string">"&lt;h1 style=</span><span class="escape">\"</span><span class="string">color:blue</span><span class="escape">\"</span><span class="string">&gt;Oi Usuário!&lt;/h1&gt;"</span><span class="p">)</span>

</code></pre>

            <p>
                <br>
                <img src="static3/oi_usuario_azul.png" alt="Azul">
                <br>
            </p>

            <p>
                Escrever uma página HTML inteira dentro do <code class="plaintext">views.py</code>. 
                se tornaria muito tedioso. Além disso, isso é uma prática ruim, já que queremos manter partes separadas do nosso 
                projeto em arquivos separados sempre que possível.
            </p>

            <p>
                É por isso que agora vamos introduzir os <a href="https://docs.djangoproject.com/en/4.0/topics/templates/" target="_blank">templates do Django</a>, 
                que nos permitirão escrever HTML e CSS em arquivos separados e renderizar esses arquivos usando o Django. 
                A sintaxe que usaremos para renderizar um template é a seguinte:
            </p>

<pre><code>
<span class="func">def</span> <span class="nome-func">index</span><span class="p">(</span><span class="python">request</span><span class="p">)</span><span>:</span>
    <span class="func">return</span> <span class="nome-func">render</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="string">"Users/index.html"</span><span class="p">)</span>

</code></pre>

            <p>
                Agora, precisaremos criar esse template. Para isso, vamos criar uma pasta chamada 
                <code class="plaintext">templates</code> dentro do nosso app, depois criar uma pasta chamada 
                <code class="plaintext">Users</code> (ou o nome do seu app) 
                dentro dela, e então adicionar um arquivo chamado <code class="plaintext">index.html</code>.
            </p>

            <p>
                <br>
                <img src="static3/arquivos.png" alt="Pastaception">
                <br>
            </p>

            <p>Em seguida, adicionaremos o que quisermos nesse novo arquivo:</p>

<pre><code>
<span class="tag">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;html</span> <span class="innertag">lang=</span><span class="classe">"pt-br"</span><span class="tag">&gt;</span>

    <span class="tag">&lt;head&gt;</span>
        <span class="tag">&lt;title&gt;</span>Usuário<span class="tag">&lt;/title&gt;</span>
    <span class="tag">&lt;/head&gt;</span>

    <span class="tag">&lt;body&gt;</span>

        <span class="tag">&lt;h1&gt;</span>Oi Usuário!<span class="tag">&lt;/h1&gt;</span>

        <span class="tag">&lt;p&gt;</span>Isso é uma página de usuário.<span class="tag">&lt;/p&gt;</span>

    <span class="tag">&lt;/body&gt;</span>

<span class="tag">&lt;/html&gt;</span>

</code></pre>

            <p>
                Agora, quando visitarmos a página principal da nossa aplicação, veremos que o cabeçalho e o título foram atualizados:
                <br>
                <img src="static3/oi_html.png" alt="Primeiro template">
                <br>
            </p>

            <p>
                Além de escrever algumas páginas HTML estáticas, também podemos usar a linguagem de templates do Django 
                para alterar o conteúdo dos nossos arquivos HTML com base na URL visitada. Vamos testar isso alterando nossa função
                <code class="plaintext">usuario</code> de antes:
            </p>

<pre><code>
<span class="func">def</span> <span class="nome-func">usuario</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="python">nome</span><span class="p">)</span><span>:</span>
    <span class="func">return</span> <span class="nome-func">render</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="string">"Users/usuario.html"</span><span>,</span> <span class="p2">{</span><span class="string">"nome"</span><span>:</span> <span class="python">nome</span><span>.</span><span class="nome-func">capitalize</span><span class="p3">()</span><span class="p2">}</span><span class="p">)</span>

</code></pre>

            <p>
                Observe que passamos um terceiro argumento para a função <code class="plaintext">render</code> 
                chamado de contexto. Nesse contexto, podemos fornecer informações que queremos que estejam disponíveis dentro dos nossos 
                arquivos HTML. Esse contexto assume a forma de um dicionário Python. Agora, podemos criar um arquivo 
                <code class="plaintext">usuario.html</code> na pasta de templates:
            </p>

<pre><code>
<span class="tag">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;html</span> <span class="innertag">lang=</span><span class="classe">"pt-br"</span><span class="tag">&gt;</span>

    <span class="tag">&lt;head&gt;</span>
        <span class="tag">&lt;title&gt;</span></span><span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span class="tag">&lt;/title&gt;</span>
    <span class="tag">&lt;/head&gt;</span>

    <span class="tag">&lt;body&gt;</span>

        <span class="tag">&lt;h1&gt;</span>Oi </span><span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span class="tag">&lt;/h1&gt;</span>

        <span class="tag">&lt;p&gt;</span>Essa é a página de </span><span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span>.</span><span class="tag">&lt;/p&gt;</span>

    <span class="tag">&lt;/body&gt;</span>

<span class="tag">&lt;/html&gt;</span>

</code></pre>

            <p>
                Você deve ter notado que usamos uma nova sintaxe: chaves duplas. 
                Essa sintaxe nos permite acessar variáveis que fornecemos no argumento de contexto. Agora, ao testarmos:
                <br>
                <img src="static3/pagina_ryan.png" alt="Template página do Ryan">
                <br>
                <img src="static3/pagina_vitor.png" alt="Template página do Vitor">
                <br>
            </p>

            <p>
                Vimos como podemos modificar nossos templates HTML com base no contexto fornecido. 
                No entanto, a linguagem de templates do Django é ainda mais poderosa do que isso, 
                então vamos dar uma olhada em algumas outras formas em que ela pode ser útil:
            </p>

            </div>

            <!-- Condicionais -->
            <div id="conditionals">

            <h2>Condicionais</h2>

            <p>
                Podemos querer alterar o que é exibido em nosso site dependendo de algumas condições. 
                Por exemplo, para nossa página de usuários, gostaríamos que algo indicasse que uma certa pessoa é uma administradora do curso.
                Para fazermos isso, vamos modificar nossa função <code class="plaintext">usuarios</code> e o arquivo <code class="plaintext">usuarios.html</code>.
            </p>

            <p>
                Antes de prosseguir, vamos descobrir como verificar se é uma pessoa é ou não um administrador do curso. 
                Suponha que, no nosso caso de exemplo, apenas o primeiro nome da pessoa importa tal que os administradores do curso são Kaiky, Ryan, Vitor e Rafael. 
            </p>

            <ul>
                <li data-marker="*">Podemos usar esse conhecimento para construir uma expressão booleana que será avaliada como True se, e somente se, hoje for o Dia de Ano Novo: <code class="plaintext">nome in [vetor com nome de adms]</code>
                <li data-marker="*">Agora que temos uma expressão para verificar se um usuário é administrador, podemos atualizar <code class="plaintext">views.py</code>:</li>
            </ul>

<pre><code>
<span class="func">def</span> <span class="nome-func">usuario</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="python">nome</span><span class="p">)</span><span>:</span>
    <span class="python">nome</span> <span class="pComment">=</span> <span class="python">nome</span><span>.</span><span class="nome-func">capitalize</span><span class="p">()</span>
    <span class="python">administradores</span> <span class="pComment">=</span> <span class="p">[</span><span class="string">"Kaiky"</span><span>,</span><span class="string">"Rafael"</span><span>,</span> <span class="string">"Ryan"</span><span>,</span> <span class="string">"Vitor"<span class="p">]</span>
    <span class="func">return</span> <span class="nome-func">render</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="string">"Users/usuario.html"</span><span>,</span> <span class="p2">{</span><span class="string">"nome"</span><span>:</span> <span class="python">nome</span><span>,</span> <span class="string">"adm"</span><span>:</span> <span class="python">nome</span> <span class="func">in</span> <span class="python">administradores</span><span class="p2">}</span><span class="p">)</span>

</code></pre>

            <p>Note que agora passamos dois "argumentos" para usuarios.html, nome(string) e adm(booleano).</p>

            <p>
                Em seguida, vamos modificar nosso template <code class="plaintext">usuarios.html</code>.  
                Dentro desse arquivo, escreveremos algo assim:
            </p>

<pre><code>
<span class="tag">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;html</span> <span class="innertag">lang=</span><span class="classe">"pt-br"</span><span class="tag">&gt;</span>

    <span class="tag">&lt;head&gt;</span>
        <span class="tag">&lt;title&gt;</span><span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span class="tag">&lt;/title&gt;</span>
    <span class="tag">&lt;/head&gt;</span>

    <span class="tag">&lt;body&gt;</span>

        <span class="tag">&lt;h1&gt;</span>Oi <span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span>!</span><span class="tag">&lt;/h1&gt;</span>

        <span class="tag">&lt;p&gt;</span>Essa é a página de <span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span>.</span><span class="tag">&lt;/p&gt;</span>

        <span class="p">{%</span> <span class="func">if</span> <span class="classe">adm</span> <span class="p">%}</span>

        <span class="tag">&lt;p&gt;</span><span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span> é um administrador.</span><span class="tag">&lt;/p&gt;</span>

        <span class="p">{%</span> <span class="func">else</span> <span class="p">%}</span>

        <span class="tag">&lt;p&gt;</span><span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span> não é um administrador.</span><span class="tag">&lt;/p&gt;</span>
                        
        <span class="p">{%</span> <span class="func">endif</span> <span class="p">%}</span>

    <span class="tag">&lt;/body&gt;</span>

<span class="tag">&lt;/html&gt;</span>

</code></pre>

            <p>
                No código acima, repare que, quando queremos incluir lógica nos nossos arquivos HTML, 
                usamos <code class="plaintext">{%</code> e 
                <code class="plaintext">%}</code> como tags de abertura e fechamento para declarações lógicas. 
                Também note que a linguagem de template do Django exige que incluamos uma tag de encerramento indicando que o bloco  
                <code class="plaintext">if-else</code> terminou. 
                Agora, podemos abrir a nossa página para ver o resultado.
            </p>

            <p>
                <br>
                <img src="static3/kaiky_adm.png" alt="É adm">
                <br>
                <img src="static3/kim_namd.png" alt="Não é adm">
                <br>
            </p>

            <p>Para entender melhor o que está acontecendo nos bastidores, vamos inspecionar o elemento dessa página:</p>

            <p>
                <br>
                <img src="static3/inspect.png" alt="Inspecionar com caso positivo">
                <br>
            </p>

            <p>
                Observe que o HTML que está sendo realmente enviado ao seu navegador inclui apenas a parte que indica que o Kaiky é um administrador, 
                o que significa que o Django está usando o template HTML que escrevemos para criar um novo arquivo HTML que possuí apenas a parte verdadeira do bloco if, e só então o envia ao navegador. 
                Se inspecionarmos a página do Kim, veremos que o caso oposto será exibido:
                <br>
                <img src="static3/inspect2.png" alt="Inspecionar com caso negativo">
                <br>
            </p>

            </div>

            <!-- Estilização -->
            <div id="styling">

            <h2>Estilização</h2>

            <p>
                Se quisermos adicionar um arquivo CSS — que é um arquivo estático, pois não muda — primeiro criaremos uma pasta chamada
                <code class="plaintext">static</code> dentro do nosso app <code class="plaintext">Users</code>, depois uma pasta 
                <code class="plaintext">Users</code> dentro dela, e então um arquivo 
                <code class="plaintext">styles.css</code> dentro dessa pasta. 
                Nesse arquivo, podemos adicionar qualquer estilo que quisermos, assim como fizemos na primeira aula:
            </p>

<pre><code>
<span class="tag">h1</span> <span class="p">{</span>
    <span class="css">font-family</span><span>:</span> <span class="css-option">sans-serif</span><span>;</span>
    <span class="css">font-size</span><span>:</span> <span class="python">50</span><span class="css">px</span><span>;</span>
    <span class="css">color</span><span>:</span> <span class="css-option">orange</span><span>;</span>
<span class="p">}</span>

</code></pre>

            <p>
                Agora, para incluir esse estilo no nosso arquivo HTML, adicionamos a linha <code class="plaintext">{% load static %}</code> no topo do nosso template HTML, 
                o que informa ao Django que queremos ter acesso aos arquivos dentro da pasta <code class="plaintext">static</code>. 
                Em vez de escrever manualmente o link para o arquivo de estilo, como fizemos antes, usaremos uma sintaxe específica do Django:
            </p>

<pre><code>
<span class="tag">&lt;link</span> <span class="innertag">rel=</span><span class="classe">"stylesheet"</span> <span class="innertag">href=</span><span class="classe">"<span class="func">{%</span> <span class="escape">static</span> <span>'Users/styles.css'</span> <span class="func">%}</span><span class="classe">"</span> </span><span class="tag">&gt;</span>

</code></pre>

            <p>De forma que nosso HTML tenha forma:</p>

<pre><code>
<span class="p">{%</span> <span class="func">load</span> <span class="escape">static</span> <span class="p">%}</span>

<span class="tag">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;html</span> <span class="innertag">lang=</span><span class="classe">"pt-br"</span><span class="tag">&gt;</span>

    <span class="tag">&lt;head&gt;</span>
        <span class="tag">&lt;title&gt;</span><span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span class="tag">&lt;/title&gt;</span>
        <span class="tag">&lt;link</span> <span class="innertag">rel=</span><span class="classe">"stylesheet"</span> <span class="innertag">href=</span><span class="classe">"<span class="func">{%</span> <span class="escape">static</span> <span>'Users/styles.css'</span> <span class="func">%}</span><span class="classe">"</span> </span><span class="tag">&gt;</span>
    <span class="tag">&lt;/head&gt;</span>

    <span class="tag">&lt;body&gt;</span>

        <span class="tag">&lt;h1&gt;</span>Oi <span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span>!</span><span class="tag">&lt;/h1&gt;</span>

        <span class="tag">&lt;p&gt;</span>Essa é a página de <span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span>.</span><span class="tag">&lt;/p&gt;</span>

        <span class="p">{%</span> <span class="func">if</span> <span class="classe">adm</span> <span class="p">%}</span>

        <span class="tag">&lt;p&gt;</span><span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span> é um administrador.</span><span class="tag">&lt;/p&gt;</span>

        <span class="p">{%</span> <span class="func">else</span> <span class="p">%}</span>

        <span class="tag">&lt;p&gt;</span><span class="p">{{</span> </span><span class="classe">nome</span> </span><span class="p">}}</span><span> não é um administrador.</span><span class="tag">&lt;/p&gt;</span>
                        
        <span class="p">{%</span> <span class="func">endif</span> <span class="p">%}</span>

    <span class="tag">&lt;/body&gt;</span>

<span class="tag">&lt;/html&gt;</span>

</code></pre>

            <p>
                Agora, se reiniciarmos o servidor, veremos que as mudanças de estilo foram aplicadas de fato:
                <br>
                <img src="static3/ryan_css.png" alt="Nome laranja">
                <br>
            </p>

            </div>

            <!-- Tarefas -->
             <div id="tasks">
            <h2>Tarefas</h2>

            <p>
                Agora, vamos pegar o que aprendemos até aqui e aplicar em um mini-projeto: criar uma lista de cursos. 
                Vamos começar, mais uma vez, criando um novo app <code class="plaintext">Cursos</code>:
            </p>

            <ol>

                <li>Execute <code class="plaintext">python manage.py startapp Cursos</code> no terminal.</li>
                <li>
                    Edite o arquivo <code class="plaintext">settings.py</code>, adicionando "Cursos" à lista <code class="plaintext">INSTALLED_APPS</code>
                    <br>
                    <img src="static3/novo_app2.png" alt="Novo app cursos">
                    <br>
                </li>
                
                <li>
                    <p>Edite o arquivo <code class="plaintext">urls.py</code> do projeto e inclua um path semelhante ao que criamos para o app <code class="plaintext">Users</code></p>

<pre><code> 
    <span class="nome-func">path</span><span class="p2">(</span><span class="string">'cursos/'</span><span>,</span> <span class="nome-func">include</span><span class="p3">(</span><span class="string">"Cursos.urls"</span><span class="p3">)</span><span class="p2">)</span>

</code></pre>

                </li>

                <li>
                    <p>
                        Crie outro arquivo <code class="plaintext">urls.py</code> dentro do diretório do 
                        novo app e atualize-o para incluir um caminho semelhante ao index do 
                        <code class="plaintext">Users</code>:
                    </p>

<pre><code>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">urls</span> <span class="func">import</span> <span class="nome-func">path</span>
<span class="func">from</span> <span>.</span> <span class="func">import</span> <span class="lib">views</span>

<span class="python">urlpatterns</span> <span class="pComment">=</span> <span class="p">[</span>
    <span class="nome-func">path</span><span class="p2">(</span><span class="string">""</span><span>,</span> <span class="lib">views</span><span>.</span><span class="nome-func">index</span><span>,</span> <span class="python">name</span><span class="pComment">=</span><span class="string">"index"</span><span class="p2">)</span>
<span class="p">]</span>

</code></pre>

                </li>

            </ol>

            <p>
                Agora, vamos começar tentando simplesmente criar uma lista de cursos e exibi-la em uma página. 
                Vamos criar uma lista Python no topo do arquivo <code class="plaintext">views.py</code> 
                onde armazenaremos nossos cursos. Depois, podemos atualizar a função <code class="plaintext">index</code> 
                para renderizar um template e fornecer nossa lista recém-criada como contexto.
            </p>

<pre><code>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">shortcuts</span> <span class="func">import</span> <span class="nome-func">render</span>

<span class="python">cursos</span> <span class="pComment">=</span> <span class="p">[</span><span class="string">"dev.learn"</span><span>,</span> <span class="string">"dev.hire"</span><span>,</span> <span class="string">"hackfools"</span><span class="p">]</span>

<span class="pComment"># Create your views here.</span>

<span class="func">def</span> <span class="nome-func">index</span><span class="p">(</span><span class="python">request</span><span class="p">)</span><span>:</span>
    <span class="func">return</span> <span class="nome-func">render</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="string">"Cursos/index.html"</span><span>,</span> <span class="p2">{</span><span class="string">"cursos"</span><span>:</span> <span class="python">cursos</span><span class="p2">}</span><span class="p">)</span>
            
</code></pre>

            <p>Agora, vamos trabalhar na criação do nosso arquivo HTML de template:</p>

<pre><code>
<span class="tag">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;html</span> <span class="innertag">lang=</span><span class="classe">"pt-br"</span><span class="tag">&gt;</span>

    <span class="tag">&lt;head&gt;</span>
        <span class="tag">&lt;title&gt;</span>Cursos<span class="tag">&lt;/title&gt;</span>
    <span class="tag">&lt;/head&gt;</span>

    <span class="tag">&lt;body&gt;</span>

        <span class="tag">&lt;h1&gt;</span>Cursos<span class="tag">&lt;/h1&gt;</span>

        <span class="tag">&lt;ul&gt;</span>

            <span class="p">{%</span> <span class="func">for</span> <span class="classe">curso</span> <span class="func">in</span> <span class="classe">cursos</span> <span class="p">%}</span>

                <span class="tag">&lt;li&gt;</span><span class="p">{{</span> </span><span class="classe">curso</span> </span><span class="p">}}</span><span class="tag">&lt;/li&gt;</span>

            <span class="p">{%</span> <span class="func">endfor</span> <span class="p">%}</span>

        <span class="tag">&lt;/ul&gt;</span>

    <span class="tag">&lt;/body&gt;</span>

<span class="tag">&lt;/html&gt;</span>

</code></pre>

            <p>
                Repare que conseguimos iterar sobre nossas tarefas usando uma sintaxe semelhante às condicionais que vimos anteriormente, 
                e também parecida com um laço for em Python. Quando acessamos a página de tarefas agora, conseguimos ver nossa lista sendo exibida:
                <br>
                <img src="static3/cursos.png" alt="Lista de cursos">
                <br>
            </p>

            </div>

            <!-- Formulários -->
            <div id="forms">

            <h2>Formulários</h2>

            <p>
                Agora que conseguimos ver todos os cursos como uma lista, talvez queiramos poder adicionar novos cursos. 
                Para isso, vamos começar a explorar o uso de forms (formulários) para atualizar uma página da web. 
                Vamos começar adicionando outra função em <code class="plaintext">views.py</code> 
                que irá renderizar uma página com um formulário para adicionar uma novo curso:
            </p>

<pre><code>
</span><span class="func">def</span> <span class="nome-func">novo_curso</span><span class="p">(</span><span class="python">request</span><span class="p">)</span><span>:</span>
    <span class="func">return</span> <span class="nome-func">render</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="string">"Cursos/novo_curso.html"</span><span class="p">)</span>

</code></pre>

            <p>Em seguida, certifique-se de adicionar outro path ao <code class="plaintext">urls.py</code>:</p>

<pre><code>
<span class="nome-func">path</span><span class="p">(</span><span class="string">"novo"</span><span>,</span> <span class="lib">views</span><span>.</span><span class="nome-func">novo_curso</span><span>,</span> <span class="python">name</span><span class="pComment">=</span><span class="string">"novo_curso"</span><span class="p">)</span>

</code></pre>

            <p>
                Agora, vamos criar nosso arquivo <code class="plaintext">novo_curso.html</code>, 
                que é bem parecido com o <code class="plaintext">index.html</code>, 
                exceto que, no corpo, incluiremos um formulário em vez de uma lista:
            </p>

<pre><code>
<span class="tag">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;html</span> <span class="innertag">lang=</span><span class="classe">"pt-br"</span><span class="tag">&gt;</span>

    <span class="tag">&lt;head&gt;</span>
        <span class="tag">&lt;title&gt;</span>Cursos<span class="tag">&lt;/title&gt;</span>
    <span class="tag">&lt;/head&gt;</span>

    <span class="tag">&lt;body&gt;</span>

        <span class="tag">&lt;h1&gt;</span>Adicionar Curso:<span class="tag">&lt;/h1&gt;</span>

        <span class="tag">&lt;form</span> <span class="innertag">action=</span><span class="classe">""</span><span class="tag">&gt;</span>

            <span class="tag">&lt;input</span> <span class="innertag">type=</span><span class="classe">"text"</span> <span class="innertag">name=</span><span class="classe">"curso"</span><span class="tag">&gt;</span>
            <span class="tag">&lt;input</span> <span class="innertag">type=</span><span class="classe">"submit"</span><span class="tag">&gt;</span>

        <span class="tag">&lt;/form&gt;</span>

    <span class="tag">&lt;/body&gt;</span>

<span class="tag">&lt;/html&gt;</span>

</code></pre>

            <p>
                No entanto, o que acabamos de fazer não é necessariamente o melhor design, pois repetimos a maior parte do HTML 
                em dois arquivos diferentes. A linguagem de template do Django nos oferece uma forma de eliminar esse design ruim: 
                <a href="https://tutorial.djangogirls.org/en/template_extending/" target="_blank">herança de template</a>. 
                Isso nos permite criar um arquivo <code class="plaintext">layout.html</code> na pasta de templates
                que conterá a estrutura geral da nossa página:
            </p>

<pre><code>
<span class="tag">&lt;!DOCTYPE html&gt;</span>
<span class="tag">&lt;html</span> <span class="innertag">lang=</span><span class="classe">"pt-br"</span><span class="tag">&gt;</span>

    <span class="tag">&lt;head&gt;</span>
        <span class="tag">&lt;title&gt;</span>Cursos<span class="tag">&lt;/title&gt;</span>
    <span class="tag">&lt;/head&gt;</span>

    <span class="tag">&lt;body&gt;</span>
        <span class="p">{%</span> <span class="func">block</span> <span class="classe">body</span> <span class="p">%}</span>
        <span class="p">{%</span> <span class="func">endblock</span> <span class="p">%}</span>
    <span class="tag">&lt;/body&gt;</span>

<span class="tag">&lt;/html&gt;</span>

</code></pre>

            <p>
                Repare que novamente usamos <code class="plaintext">{%...%}</code> para indicar algum 
                tipo de lógica não-HTML e, nesse caso, estamos dizendo ao Django para preencher esse "bloco" com algum conteúdo 
                vindo de outro arquivo. Agora, podemos alterar nossos outros dois arquivos HTML para ficarem assim:
            </p>

            <p><code class="plaintext">index.html</code>:</p>

<pre><code>
<span class="p">{%</span> <span class="func">extends</span> <span class="classe">"Cursos/layout.html"</span> <span class="p">%}</span>

<span class="p">{%</span> <span class="func">block</span> <span class="classe">body</span> <span class="p">%}</span>

    <span class="tag">&lt;h1&gt;</span>Cursos<span class="tag">&lt;/h1&gt;</span>

    <span class="tag">&lt;ul&gt;</span>

        <span class="p">{%</span> <span class="func">for</span> <span class="classe">curso</span> <span class="func">in</span> <span class="classe">cursos</span> <span class="p">%}</span>

            <span class="tag">&lt;li&gt;</span><span class="p">{{</span> </span><span class="classe">curso</span> </span><span class="p">}}</span><span class="tag">&lt;/li&gt;</span>

        <span class="p">{%</span> <span class="func">endfor</span> <span class="p">%}</span>

    <span class="tag">&lt;/ul&gt;</span>

<span class="p">{%</span> <span class="func">endblock</span> <span class="p">%}</span>

</code></pre>

            <p><code class="plaintext">novo_curso.html</code>:</p>

<pre><code>
<span class="p">{%</span> <span class="func">extends</span> <span class="classe">"Cursos/layout.html"</span> <span class="p">%}</span>

<span class="p">{%</span> <span class="func">block</span> <span class="classe">body</span> <span class="p">%}</span>

    <span class="tag">&lt;h1&gt;</span>Adicionar Curso:<span class="tag">&lt;/h1&gt;</span>

    <span class="tag">&lt;form</span> <span class="innertag">action=</span><span class="classe">""</span><span class="tag">&gt;</span>

        <span class="tag">&lt;input</span> <span class="innertag">type=</span><span class="classe">"text"</span> <span class="innertag">name=</span><span class="classe">"curso"</span><span class="tag">&gt;</span>
        <span class="tag">&lt;input</span> <span class="innertag">type=</span><span class="classe">"submit"</span><span class="tag">&gt;</span>

    <span class="tag">&lt;/form&gt;</span>

<span class="p">{%</span> <span class="func">endblock</span> <span class="p">%}</span>

</code></pre>

            <p>
                Perceba como agora conseguimos eliminar grande parte do código repetido ao estender nosso arquivo de layout. 
                Assim, nossa página index continua a mesma e agora temos também uma página add:
            </p>

            <p>
                <br>
                <img src="static3/novo_curso.png" alt="Novo curso">
                <br>
            </p>

            <p>
                Em seguida, não é ideal ter que digitar "/novo" na URL toda vez que quisermos adicionar uma novo curso, 
                então provavelmente vamos querer adicionar alguns links entre as páginas. Em vez de codificar os links diretamente, 
                agora podemos usar a variável <code class="plaintext">name</code> que atribuímos a cada rota no 
                <code class="plaintext">urls.py</code> e criar um link assim:
            </p>

<pre><code>
<span class="tag">&lt;a</span> <span class="innertag">href=</span><span class="classe">"</span><span class="func">{% url</span> <span class="classe">'novo_curso'</span> <span class="func">%}</span><span class="classe">"</span><span class="tag">&gt;</span>Adicionar novo curso<span class="tag">&lt;/a&gt;</span>

</code></pre>

            <p>Onde 'novo_curso' é o nome daquela rota. Podemos fazer algo semelhante em nosso <code class="plaintext">novo_curso.html</code>:</p>

<pre class="highlight"><code>
<span class="tag">&lt;a</span> <span class="innertag">href=</span><span class="classe">"</span><span class="func">{% url</span> <span class="classe">'index'</span> <span class="func">%}</span><span class="classe">"</span><span class="tag">&gt;</span>Adicionar novo curso<span class="tag">&lt;/a&gt;</span>
            
</code></pre>

            <p>
                Isso, no entanto, pode criar um problema, já que temos algumas rotas chamadas 
                <code class="plaintext">index</code> em diferentes apps. Podemos resolver isso indo em cada 
                um dos arquivos <code class="plaintext">urls.py</code> dos nossos apps e adicionando uma variável 
                <code class="plaintext">app_name</code> para que os arquivos agora fiquem parecidos com isto:
            </p>

<pre><code>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">urls</span> <span class="func">import</span> <span class="nome-func">path</span>
<span class="func">from</span> <span>.</span> <span class="func">import</span> <span class="lib">views</span>

<span class="python">app_name</span> <span class="pComment">=</span> <span class="string">"Cursos"</span>

<span class="python">urlpatterns</span> <span class="pComment">=</span> <span class="p">[</span>
    <span class="nome-func">path</span><span class="p2">(</span><span class="string">""</span><span>,</span> <span class="lib">views</span><span>.</span><span class="nome-func">index</span><span>,</span> <span class="python">name</span><span class="pComment">=</span><span class="string">"index"</span><span class="p2">)</span><span>,</span>
    <span class="nome-func">path</span><span class="p2">(</span><span class="string">"novo"</span><span>,</span> <span class="lib">views</span><span>.</span><span class="nome-func">novo_curso</span><span>,</span> <span class="python">name</span><span class="pComment">=</span><span class="string">"novo_curso"</span><span class="p2">)</span>
<span class="p">]</span>

</code></pre>

            <p>
                Com isso, podemos mudar nossos links de simplesmente <code class="plaintext">index</code> e 
                <code class="plaintext">novo_curso</code> para 
                <code class="plaintext">Cursos:index</code> e 
                <code class="plaintext">Cursos:novo_curso</code>
            </p>

<pre><code>
<span class="tag">&lt;a</span> <span class="innertag">href=</span><span class="classe">"</span><span class="func">{% url</span> <span class="classe">'Cursos:index'</span> <span class="func">%}</span><span class="classe">"</span><span class="tag">&gt;</span>Adicionar novo curso<span class="tag">&lt;/a&gt;</span>

<span class="tag">&lt;a</span> <span class="innertag">href=</span><span class="classe">"</span><span class="func">{% url</span> <span class="classe">'Cursos:novo_curso'</span> <span class="func">%}</span><span class="classe">"</span><span class="tag">&gt;</span>Adicionar novo curso<span class="tag">&lt;/a&gt;</span>
            
</code></pre>

            <p>
                <br>
                <img src="static3/redirect1.png" alt="Redirecionamento para novo curso">
                <br>
                <img src="static3/redirect2.png" alt="Redirecionamento para lista de cursos">
                <br>
            </p>

            <p>
                Agora, vamos trabalhar para garantir que o formulário realmente faça algo quando o usuário o submeter. 
                Podemos fazer isso adicionando um <code class="plaintext">action</code> no formulário que criamos em 
                <code class="plaintext">novo_curso.html</code>:
            </p>

<pre><code>
    <span class="tag">&lt;form</span> <span class="innertag">action=</span><span class="classe">"</span><span class="func">{% url</span> <span class="classe">'Cursos:novo_curso'</span> <span class="func">%}</span><span class="classe">"</span> <span class="innertag">method=</span><span class="classe">"post"</span><span class="tag">&gt;</span>

</code></pre>

            <p>
                Isso significa que, ao submeter o formulário, seremos redirecionados novamente à URL 
                <code class="plaintext">/novo</code>. Aqui, especificamos que usaremos o método 
                <em>post</em> em vez do método <em>get</em> que é o mais apropriado sempre que um formulário pode alterar o estado da página.
            </p>

            <p>
                Precisamos adicionar um pouco mais ao nosso formulário agora, porque o Djan go exigeum token para prevenir ataques de 
                falsificação de solicitação entre sites <a href="https://portswigger.net/web-security/csrf" target="_blank">(Cross-Site Request Forgery, ou CSRF)</a>. 
                Esse é um tipo de ataque onde um usuário malicioso tenta enviar uma requisição para seu servidor a partir de outro site que 
                não é o seu. Isso pode ser um problema sério para alguns sites. Suponha, por exemplo, que um site de banco tenha um formulário 
                para um usuário transferir dinheiro para outro. Seria catastrófico se alguém conseguisse submeter uma transferência a partir de 
                fora do site do banco!
            </p>

            <p>
                Para resolver esse problema, quando o Django envia uma resposta renderizando um template, ele também fornece um <strong>token CSRF</strong> 
                que é único para cada nova sessão no site. Então, quando uma requisição é submetida, o Django verifica se o token CSRF associado 
                à requisição corresponde a um que foi fornecido recentemente. Assim, se um usuário malicioso em outro site tentar submeter uma 
                requisição, ela será bloqueada devido a um token CSRF inválido. Essa validação CSRF é integrada ao 
                <a href="https://docs.djangoproject.com/en/4.0/topics/http/middleware/" target="_blank">Middleware do Django</a>, que pode intervir no 
                processamento de requisições e respostas de uma aplicação Django. Não entraremos em mais detalhes sobre Middleware neste curso, 
                mas vale a pena consultar a <a href="https://docs.djangoproject.com/en/4.0/topics/http/middleware/" target="_blank">documentação</a> se estiver interessado!
            </p>

            <p>
                Para incorporar essa proteção no nosso código, devemos adicionar a linha <code class="plaintext">{% csrf_token %}</code> ao nosso formulário em 
                <code class="plaintext">novo_curso.html</code>.
            </p>

<pre><code>
<span class="p">{%</span> <span class="func">extends</span> <span class="classe">"Cursos/layout.html"</span> <span class="p">%}</span>

<span class="p">{%</span> <span class="func">block</span> <span class="classe">body</span> <span class="p">%}</span>

    <span class="tag">&lt;h1&gt;</span>Adicionar Curso:<span class="tag">&lt;/h1&gt;</span>

    <span class="tag">&lt;form</span> <span class="innertag">action=</span><span class="classe">"</span><span class="p">{% url</span> <span class="classe">'Cursos:novo_curso'</span> <span class="p">%}</span><span class="classe">"</span> <span class="innertag">method=</span><span class="classe">"post"</span><span class="tag">&gt;</span>
        <span class="p">{%</span> <span class="func">csfr_token</span> <span class="p">%}</span>

        <span class="tag">&lt;input</span> <span class="innertag">type=</span><span class="classe">"text"</span> <span class="innertag">name=</span><span class="classe">"curso"</span><span class="tag">&gt;</span>
        <span class="tag">&lt;input</span> <span class="innertag">type=</span><span class="classe">"submit"</span><span class="tag">&gt;</span>

    <span class="tag">&lt;/form&gt;</span>

<span class="p">{%</span> <span class="func">endblock</span> <span class="p">%}</span>

</code></pre>

            <p>
                Essa linha adiciona um campo oculto com o token CSRF fornecido pelo Django, de forma que, ao recarregarmos a página, 
                parece que nada mudou. No entanto, se inspecionarmos o elemento, notaremos que um novo campo de entrada foi adicionado:
                <br>
                <img src="static3/inspect3.png" alt="HTML do token CSRF">
                <br>
            </p>

            </div>

            <!-- Formulários do Django -->
            <div id="django-forms">

            <h2>Formulários do Django</h2>

            <p>
                Embora possamos criar formulários escrevendo HTML puro, como acabamos de fazer, o Django fornece uma maneira ainda mais 
                fácil de coletar informações de um usuário: os <a href="https://docs.djangoproject.com/en/4.0/ref/forms/api/" target="_blank">Formulários do Django</a>. 
                Para usar esse método, adicionaremos o seguinte no topo do <code class="plaintext">views.py</code> 
                para importar o módulo <code class="plaintext">forms</code>:
            </p>

<pre class="highlight"><code>
<span class="func">from</span> <span class="lib">django</span> <span class="func">import</span> <span class="lib">forms</span>

</code></pre>

            <p>
                Agora, podemos criar um novo formulário dentro de <code class="plaintext">views.py</code> 
                criando uma classe Python chamada <code class="plaintext">NewTaskForm</code>:
            </p>

<pre><code>
<span class="func">class</span> <span class="lib">NewTaskForm</span><span class="p">(</span><span class="lib">forms</span><span>.</span><span class="lib">Form</span><span class="p">)</span><span>:</span>
    <span class="func">curso</span> <span class="pComment">=</span> <span class="lib">forms</span><span>.</span><span class="lib">CharField</span><span class="p">(</span><span class="python">label</span><span class="pComment">=</span><span class="string">"Novo Curso"</span><span class="p">)</span>
            
</code></pre>

            <p>Agora, vamos entender o que está acontecendo dentro dessa classe:</p>

            <ul>

                <li data-marker="*">
                    Dentro dos parênteses após <code class="plaintext">NewTaskForm</code>, 
                    vemos que temos <code class="plaintext">forms.Form</code>. 
                    Isso acontece porque nosso novo formulário herda de uma classe chamada 
                    <code class="plaintext">Form</code> que está incluída no módulo <code class="plaintext">forms</code>. 
                    Já vimos como a herança pode ser usada na linguagem de templates do Django. 
                    Este é mais um exemplo de como a herança é usada para partir de uma descrição mais geral 
                    (a classe <code class="plaintext">forms.Form</code>) e refiná-la para o que desejamos 
                    (nosso novo formulário). A herança é uma parte fundamental da Programação Orientada a Objetos, que não discutiremos 
                    em profundidade neste curso, mas existem <a href="https://www.w3schools.com/python/python_inheritance.asp" target="_blank">muitos recursos online</a> 
                    disponíveis para quem quiser aprender mais sobre o assunto!
                </li>
                
                <li data-marker="*">Dentro dessa classe, podemos especificar quais informações gostaríamos de coletar do usuário — neste caso, o nome de um curso.</li>
           
                <li data-marker="*">
                    Especificamos que isso deve ser um campo de texto usando <code class="plaintext">forms.CharField</code>, 
                    mas há <a href="https://docs.djangoproject.com/en/4.0/ref/forms/fields/#built-in-field-classes" target="_blank">muitos outros tipos de campos</a> 
                    disponíveis no módulo de formulários do Django que podemos usar.
                </li>

                <li data-marker="*">
                    Dentro desse <code class="plaintext">CharField</code>, 
                    especificamos um <code class="plaintext">label</code>, que será exibido para o usuário 
                    quando ele carregar a página. Um <code class="plaintext">label</code> é apenas um dos 
                    <a href="https://docs.djangoproject.com/en/4.0/ref/forms/fields/#core-field-arguments" target="_blank">muitos argumentos</a> 
                    que podemos passar para um campo de formulário.
                </li>

            </ul>

            <p>
                Agora que criamos a classe <code class="plaintext">NewTaskForm</code>, 
                podemos incluí-la no contexto ao renderizar a página <code class="plaintext">novo_curso</code>
            </p>

<pre><code>
</span><span class="func">def</span> <span class="nome-func">novo_curso</span><span class="p">(</span><span class="python">request</span><span class="p">)</span><span>:</span>
    <span class="func">return</span> <span class="nome-func">render</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="string">"Cursos/novo_curso.html"</span><span>,</span> <span class="p2">{</span><span class="string">"form"</span><span>:</span> <span class="lib">NewTaskForm</span><span class="p3">()</span><span class="p2">}</span><span class="p">)</span>

</code></pre>

            <p>
                Agora, dentro do <code class="plaintext">novo_curso.html</code>, 
                podemos substituir nosso campo de entrada (input) pelo formulário que acabamos de criar:
            </p>

<pre><code>
<span class="p">{%</span> <span class="func">extends</span> <span class="classe">"Cursos/layout.html"</span> <span class="p">%}</span>

<span class="p">{%</span> <span class="func">block</span> <span class="classe">body</span> <span class="p">%}</span>

    <span class="tag">&lt;h1&gt;</span>Adicionar Curso:<span class="tag">&lt;/h1&gt;</span>

    <span class="tag">&lt;form</span> <span class="innertag">action=</span><span class="classe">"</span><span class="p">{% url</span> <span class="classe">'Cursos:novo_curso'</span> <span class="p">%}</span><span class="classe">"</span> <span class="innertag">method=</span><span class="classe">"post"</span><span class="tag">&gt;</span>
        <span class="p">{%</span> <span class="func">csfr_token</span> <span class="p">%}</span>

        <span class="p">{%</span> <span class="classe">form</span> <span class="p">%}</span>
        <span class="tag">&lt;input</span> <span class="innertag">type=</span><span class="classe">"submit"</span><span class="tag">&gt;</span>

    <span class="tag">&lt;/form&gt;</span>

    <span class="tag">&lt;a</span> <span class="innertag">href=</span><span class="classe">"</span><span class="func">{% url</span> <span class="classe">'Cursos:index'</span> <span class="func">%}</span><span class="classe">"</span><span class="tag">&gt;</span><span>Ver cursos</span><span class="tag">&lt;/a&gt;</span>

<span class="p">{%</span> <span class="func">endblock</span> <span class="p">%}</span>

</code></pre>

            <p>
                Existem várias vantagens em usar o módulo <code class="plaintext">forms</code> 
                em vez de escrever manualmente um formulário HTML:
            </p>
       
            <ul>
                <li data-marker="*">Se quisermos adicionar novos campos ao formulário, podemos simplesmente adicioná-los em <code class="plaintext">views.py</code> sem precisar escrever HTML adicional.</li>
                <li data-marker="*">
                    O Django executa automaticamente a <a href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation" target="_blank">validação no lado do cliente</a>, 
                    ou seja, no próprio navegador do usuário. Isso significa que ele não permitirá que o usuário envie o formulário se ele estiver incompleto.
                </li>
                <li data-marker="*">
                    O Django também fornece <a href="https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation" target="_blank">validação no lado do servidor</a>, 
                    ou seja, após os dados do formulário chegarem ao servidor.
                </li>
                <li data-marker="*">Na próxima aula, começaremos a usar <strong>models</strong> para armazenar informações, e o Django torna muito simples criar um formulário baseado em um modelo.</li>
            </ul>

            <p>
                Agora que temos um formulário configurado, vamos trabalhar no que acontece quando um usuário clica no botão de envio. 
                Quando um usuário acessa a página de adição clicando em um link ou digitando a URL, ele envia uma requisição  
                <code class="plaintext">GET</code> para o servidor, que já tratamos na nossa função 
                <code class="plaintext">novo_curso</code>. No entanto, quando ele envia um formulário, ele faz uma requisição 
                <code class="plaintext">POST</code> para o servidor, que no momento ainda não está sendo tratada na função 
                <code class="plaintext">novo_curso</code>. Podemos tratar o método 
                <code class="plaintext">POST</code> adicionando uma condição baseada no argumento 
                <code class="plaintext">request</code> que nossa função recebe. Os comentários no código 
                abaixo explicam o propósito de cada linha:
            </p>

<pre><code>
<span class="func">def</span> <span class="nome-func">novo_curso</span><span class="p">(</span><span class="python">request</span><span class="p">)</span><span>:</span>

    <span class="func">if</span> <span class="p">(</span><span class="python">request</span><span>.</span><span class="func">method</span> <span class="pComment">==</span> <span class="string">"POST"</span><span class="p">)</span><span>:</span>

        <span class="pComment"># Salva em um form os dados submetidos pelo usuário</span>
        <span class="python">form</span> <span class="pComment">=</span> <span class="lib">NewTaskForm</span><span class="p">(</span><span class="python">request</span><span>.</span><span class="escape">POST</span><span class="p">)</span>

        <span class="pComment"># Checa se os dados do form são válidos (server-side)</span>
        <span class="func">if</span> <span class="p">(</span><span class="python">form</span><span>.</span><span class="nome-func">is_valid</span><span class="p2">()</span><span class="p">)</span><span>:</span>

            <span class="pComment">#Isola o curso da versão 'limpa' dos dados do form</span>
            <span class="python">curso</span> <span class="pComment">=</span> <span class="python">form</span><span>.</span><span class="func">cleaned_data</span><span class="p">[</span><span class="string">"curso"</span><span class="p">]</span>

            <span class="pComment"># Adiciona o novo curso na lista de cursos</span>
            <span class="python">cursos</span><span>.</span><span class="nome-func">append</span><span class="p">(</span><span class="python">curso</span><span class="p">)</span>

            <span class="pComment"># Redireciona o usuário para a lista de cursos</span>
            <span class="func">return</span> <span class="lib">HttpResponseRedirect</span><span class="p">(</span><span class="nome-func">reverse</span><span class="p2">(</span><span class="string">"</span><span class="classe">Cursos:index</span><span class="string">"</span><span class="p2">)</span><span class="p">)</span>

        <span class="func">else</span><span>:</span>

            <span class="pComment"># Se o formulário é inválido, re-renderiza a página com informações existentes.</span>
            <span class="func">return</span> <span class="nome-func">render</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="string">"Cursos/novo_curso.html"</span><span>,</span> <span class="p2">{</span><span class="string">"form"</span><span class="p">:</span> <span class="python">form</span><span class="p2">}</span><span class="p">)</span>

        <span class="func">return</span> <span class="nome-func">render</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="string">"Cursos/novo_curso.html"</span><span>,</span> <span class="p2">{</span><span class="string">"form"</span><span>:</span> <span class="lib">NewTaskForm</span><span class="p3">()</span><span class="p2">}</span><span class="p">)</span>

</code></pre>

            <p>Observação - para redirecionar o usuário após um envio bem-sucedido, precisaremos de mais alguns imports:</p>

<pre><code>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">urls</span> <span class="func">import</span> <span class="nome-func">reverse</span>
<span class="func">from</span> <span class="lib">django</span><span>.</span><span class="lib">http</span> <span class="func">import</span> <span class="lib">HttpResponseRedirect</span>

</code></pre>

            <p>
                Finalmente, podemos adicionar um curso:
                <br>
                <img src="static3/add_curso1.png" alt="Adicionando novo curso">
                <br>
                <img src="static3/add_curso2.png" alt="Novo curso na lista de cursos">
                <br>
            </p>

            </div>

            <!-- Sessões -->
            <div id="sessions">

            <h2>Sessões</h2>

            <p>
                Neste ponto, conseguimos construir uma aplicação que nos permite adicionar cursos a uma lista crescente. 
                No entanto, pode ser problemático armazenar essas tarefas como uma variável global, pois isso significa que todos os 
                usuários que acessam a página veem exatamente a mesma lista. Para resolver esse problema, vamos usar uma ferramenta conhecida como 
                <a href="https://docs.djangoproject.com/en/4.0/topics/http/sessions/" target="_blank">sessões</a>.
            </p>

            <p>Sessões são uma maneira de armazenar dados únicos no lado do servidor para cada nova visita a um site.</p>

            <p>
                Para usar sessões em nossa aplicação, primeiro vamos deletar a variável global <code class="plaintext">cursos</code>, 
                depois alterar nossa função <code class="plaintext">index</code>, e por fim, garantir que em 
                todos os lugares onde usamos a variável <code class="plaintext">cursos</code> ela seja substituida por 
                <code class="plaintext">request.session["cursos"]</code>
            </p>

<pre><code>
<span class="func">def</span> <span class="nome-func">index</span><span class="p">(</span><span class="python">request</span><span class="p">)</span><span>:</span>

    <span class="pComment"># Verifica se já existe uma chave "cursos" na sessão atual</span>
    <span class="func">if</span> <span class="p">(</span><span class="string">"cursos"</span> <span class="escape">not</span> <span class="func">in</span> <span class="python">request</span><span>.</span><span class="func">session</span><span class="p">)</span><span>:</span>

        <span class="pComment"># Se não estiver, cria uma lista nova</span>
        <span class="python">request</span><span>.</span><span class="func">session</span><span class="p">[</span><span class="string">"cursos"</span><span class="p">]</span> <span class="pComment">=</span> <span class="p">[]</span>

    <span class="func">return</span> <span class="nome-func">render</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="string">"Cursos/index.html"</span><span>,</span> <span class="p2">{</span><span class="string">"cursos"</span><span>:</span> <span class="python">request</span><span class="p">.</span><span class="func">session</span><span class="p3">[</span><span class="string">"cursos"</span><span class="p3">]</span><span class="p2">}</span><span class="p">)</span>

<span class="func">def</span> <span class="nome-func">novo_curso</span><span class="p">(</span><span class="python">request</span><span class="p">)</span><span>:</span>

    <span class="func">if</span> <span class="p">(</span><span class="python">request</span><span>.</span><span class="func">method</span> <span class="pComment">==</span> <span class="string">"POST"</span><span class="p">)</span><span>:</span>

        <span class="pComment"># Salva em um form os dados submetidos pelo usuário</span>
        <span class="python">form</span> <span class="pComment">=</span> <span class="lib">NewTaskForm</span><span class="p">(</span><span class="python">request</span><span>.</span><span class="escape">POST</span><span class="p">)</span>

        <span class="pComment"># Checa se os dados do form são válidos (server-side)</span>
        <span class="func">if</span> <span class="p">(</span><span class="python">form</span><span>.</span><span class="nome-func">is_valid</span><span class="p2">()</span><span class="p">)</span><span>:</span>

            <span class="pComment">#Isola o curso da versão 'limpa' dos dados do form</span>
            <span class="python">curso</span> <span class="pComment">=</span> <span class="python">form</span><span>.</span><span class="func">cleaned_data</span><span class="p">[</span><span class="string">"curso"</span><span class="p">]</span>

            <span class="pComment"># Adiciona o novo curso na lista de cursos</span>
            <span class="python">request</span><span>.</span><span class="func">session</span><span class="p">[</span><span class="string">"cursos"</span><span class="p">]</span> <span class="pComment">+=</span> <span class="p">[</span><span class="python">curso</span><span class="p">]</span>

            <span class="pComment"># Redireciona o usuário para a lista de cursos</span>
            <span class="func">return</span> <span class="lib">HttpResponseRedirect</span><span class="p">(</span><span class="nome-func">reverse</span><span class="p2">(</span><span class="string">"Cursos:index"</span><span class="p2">)</span><span class="p">)</span>

        <span class="func">else</span><span>:</span>

            <span class="pComment"># Se o formulário é inválido, re-renderiza a página com informações existentes.</span>
            <span class="func">return</span> <span class="nome-func">render</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="string">"Cursos/novo_curso.html"</span><span>,</span> <span class="p2">{</span><span class="string">"form"</span><span>:</span> <span class="python">form</span><span class="p2">}</span><span class="p">)</span>

    <span class="func">return</span> <span class="nome-func">render</span><span class="p">(</span><span class="python">request</span><span>,</span> <span class="string">"Cursos/novo_curso.html"</span><span>,</span> <span class="p2">{</span><span class="string">"form"</span><span>:</span> <span class="lib">NewTaskForm</span><span class="p3">()</span><span class="p2">}</span><span class="p">)</span>

</code></pre>

            <p>
                Assim, temos que as telas por sessão serão:
                <br>
                <img src="static3/new_session.png" alt="Nova sessão">
                <br>
                <img src="static3/new_session_add.png" alt="Adicionando curso em nova sessão">
                <br>
                <img src="static3/new_session_added.png" alt="Novo curso adicionado na lista da sessão">
                <br>
            </p>

            <p>
                Por fim, antes que o Django possa armazenar esses dados, devemos executar o seguinte comando no terminal: 
                <code class="plaintext">python manage.py migrate</code> in the terminal. 
                Na próxima semana falaremos mais sobre o que é uma migration (migração), mas por enquanto, basta saber que esse comando permite que o Django armazene sessões.
            </p>

            <p>
                Isso é tudo por esta aula!
                <br>
                Na próxima, trabalharemos com o uso do Django para armazenar, acessar e manipular dados.
            </p>

            </div>

        </main>

    </body>

</html>